<?xml version="1.0" encoding="UTF-8"?>
<Derby>
    <jdbc-driver>org.apache.derby.jdbc.ClientDriver</jdbc-driver>
    <jdbc-url>jdbc:derby://127.0.0.1:10788/flashchat;create=true</jdbc-url>
    <database-user/>
    <database-password/>
    <user-table>users</user-table>
    <username-field>user_name</username-field>
    <password-field>password</password-field>
    <enable-md5>On</enable-md5>
    <connection-pool>
        <!--house-keeping-sleep-time
            This is the time the house keeping thread sleeps for between checks. (milliseconds)
        -->
        <house-keeping-sleep-time>40000</house-keeping-sleep-time>
        <!--house-keeping-test-sql
            The test SQL that we perform to see if a connection is alright. Should be fast and robust.
        -->
        <house-keeping-test-sql>select status from server_info</house-keeping-test-sql>
        <!--maximum-connection-count
            The maximum number of connections to the database
        -->
        <maximum-connection-count>60</maximum-connection-count>
        <!--minimum-connection-count
            The minimum number of connections we will keep open, regardless of whether anyone needs them or not.
        -->
        <minimum-connection-count>5</minimum-connection-count>
        <!--maximum-connection-lifetime
            The maximum amount of time that a connection exists for before it is killed (recycled). (milliseconds)
        -->
        <maximum-connection-lifetime>18000000</maximum-connection-lifetime>
        <!--simultaneous-build-throttle
            In order to prevent overloading, this is the maximum number of connections that you can have that are in the progress of being made. That is, ones we have started to make but haven't finished yet.
        -->
        <simultaneous-build-throttle>50</simultaneous-build-throttle>
        <!--recently-started-threshold
            As long as we have one connection that was started within this threshold then we consider the pool to be up. (That is, not down). This allows us to differentiate between having all the connections frozen and just being really busy.
        -->
        <recently-started-threshold>40000</recently-started-threshold>
        <!--overload-without-refusal-lifetime
            This is the time in milliseconds after the last time that we refused a connection that we still consider ourselves to be overloaded. We have to do this because, even when overloaded, it's not impossible for the available connection count to be high and it's possible to be serving a lot of connections. Recognising an overload is easy (we refuse a connection) - it's recognising when we stop being overloaded that is hard. Hence this fudge :)
        -->
        <overload-without-refusal-lifetime>50000</overload-without-refusal-lifetime>
        <!--maximum-active-time
            If the housekeeper comes across a thread that has been active for longer than this then it will kill it. So make sure you set this to a number bigger than your slowest expected response!
        -->
        <maximum-active-time>60000</maximum-active-time>
        <!--verbose
            If this is true then we start logging a lot of stuff everytime we serve a connection and everytime the house keeper and prototyper run. Be prepared for a lot of debug!
        -->
        <verbose>false</verbose>
        <!--trace
            If this is true then we will log each execution. The SQL used and the execution time.    
        -->
        <trace>false</trace>
        <!--fatal-sql-exception
            Get the list of fatal SQL exception (Strings) fragments that will trigger the death of a Connection. All SQLExceptions are caught and tested for containing this text fragment. If it matches than this connection is considered useless and it is discarded. Regardless of what happens the exception is always thrown back to the user.
        -->
        <fatal-sql-exception>Fatal error</fatal-sql-exception>
        <!--prototype-count
            This is the number of spare connections we will strive to have. So, if we have a prototypeCount of 5 but only 3 spare connections the prototyper will make an additional 2. This is important because it can take around a seconds to establish a connection, and if we are being very strict about killing connections when they get too old it happens a fair bit.
        -->
        <prototype-count>2</prototype-count>
    </connection-pool>
</Derby>
